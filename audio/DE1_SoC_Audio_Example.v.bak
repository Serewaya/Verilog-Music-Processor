
module DE1_SoC_Audio_Example (
	// Inputs
	CLOCK_50,
	AUD_ADCDAT,
	clip_trigger,

	// Bidirectionals
	AUD_BCLK,
	AUD_ADCLRCK,
	AUD_DACLRCK,
	FPGA_I2C_SDAT,

	// Outputs
	AUD_XCK,
	AUD_DACDAT,
	FPGA_I2C_SCLK,
	clip_playing
);





/*****************************************************************************
 *                           Parameter Declarations                          *
 *****************************************************************************/


/*****************************************************************************
 *                             Port Declarations                             *
 *****************************************************************************/
// Inputs
input				CLOCK_50;
input				AUD_ADCDAT;
input [7:0]			clip_trigger;

// Bidirectionals
inout				AUD_BCLK;
inout				AUD_ADCLRCK;
inout				AUD_DACLRCK;
inout				FPGA_I2C_SDAT;

// Outputs
output				AUD_XCK;
output				AUD_DACDAT;
output				FPGA_I2C_SCLK;
output reg			clip_playing;

/*****************************************************************************
 *                 Internal Wires and Registers Declarations                 *
 *****************************************************************************/
// Audio Controller Wires
wire				audio_in_available;
wire	signed	[31:0]	left_channel_audio_in;
wire	[31:0]		right_channel_audio_in;
wire				audio_out_allowed;

// Audio Output Wires
wire	[31:0]		left_channel_audio_out;
wire	[31:0]		right_channel_audio_out;
wire				write_audio_out;

// Control Signals
wire				trigger_asserted;
assign trigger_asserted = |clip_trigger;  // OR all trigger bits

// State and Timing Registers
reg	[1:0]		playback_state;
reg	[27:0]		frame_counter;
reg	[14:0]		clip_address;






// State Machine Registers

/*****************************************************************************
 *                         Finite State Machine(s)                           *
 *****************************************************************************/

// Simple playback state machine
localparam IDLE = 2'b00;
localparam PLAYING = 2'b01;
localparam STOPPING = 2'b10;

always @(posedge CLOCK_50) begin
	case (playback_state)
		IDLE: begin
			// Wait for trigger signal
			if (trigger_asserted) begin
				playback_state <= PLAYING;
			end
		end
		
		PLAYING: begin
			// Continue playing until clip reaches end
			if (clip_address >= 15'd17721) begin
				playback_state <= STOPPING;
			end
		end
		
		STOPPING: begin
			// Reset and return to idle
			playback_state <= IDLE;
		end
		
		default: playback_state <= IDLE;
	endcase
end
/*****************************************************************************
 *                             Sequential Logic                              *
 *****************************************************************************/

// ROM audio sample output
wire [32:0]		soundout;
wire [14:0]		rom_address;
assign rom_address = clip_address;
soundrom sample_rom(rom_address, CLOCK_50, soundout);

// Frame timing counter (controls sample rate)
localparam FRAME_RATE = 5000;  // 5000 frames per second
localparam CLOCKS_PER_FRAME = 50000000 / FRAME_RATE;  // 10,000 cycles

always @(posedge CLOCK_50) begin
	if (frame_counter >= CLOCKS_PER_FRAME - 1) begin
		frame_counter <= 0;
	end else begin
		frame_counter <= frame_counter + 1;
	end
end

// Clip address advancement
always @(posedge CLOCK_50) begin
	if (playback_state == IDLE) begin
		clip_address <= 0;
	end else if (playback_state == PLAYING && frame_counter == 0) begin
		clip_address <= clip_address + 1;
	end
end

// Output audio sample
wire [31:0] audio_sample = soundout >> 2;
assign left_channel_audio_out = (playback_state == PLAYING) ? audio_sample : 32'h0;
assign right_channel_audio_out = (playback_state == PLAYING) ? audio_sample : 32'h0;
assign write_audio_out = (playback_state == PLAYING) & audio_out_allowed;

// Indicate when clip is actively playing
always @(posedge CLOCK_50) begin
	clip_playing <= (playback_state == PLAYING);
end
/*****************************************************************************
 *                            Combinational Logic                            *
 *****************************************************************************/

// No additional combinational logic needed



/*****************************************************************************
 *                              Internal Modules                             *
 *****************************************************************************/

Audio_Controller Audio_Controller (
	// Inputs
	.CLOCK_50					(CLOCK_50),
	.reset						(1'b0),

	.clear_audio_in_memory		(),
	.read_audio_in				(1'b0),
	
	.clear_audio_out_memory		(),
	.left_channel_audio_out		(left_channel_audio_out),
	.right_channel_audio_out	(right_channel_audio_out),
	.write_audio_out			(write_audio_out),

	.AUD_ADCDAT					(AUD_ADCDAT),

	// Bidirectionals
	.AUD_BCLK					(AUD_BCLK),
	.AUD_ADCLRCK				(AUD_ADCLRCK),
	.AUD_DACLRCK				(AUD_DACLRCK),

	// Outputs
	.audio_in_available			(audio_in_available),
	.left_channel_audio_in		(left_channel_audio_in),
	.right_channel_audio_in		(right_channel_audio_in),

	.audio_out_allowed			(audio_out_allowed),

	.AUD_XCK					(AUD_XCK),
	.AUD_DACDAT					(AUD_DACDAT)
);

avconf #(.USE_MIC_INPUT(1)) avc (
	.FPGA_I2C_SCLK				(FPGA_I2C_SCLK),
	.FPGA_I2C_SDAT				(FPGA_I2C_SDAT),
	.CLOCK_50					(CLOCK_50),
	.reset						(1'b0)
);

endmodule




